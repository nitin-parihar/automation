name: Azure VM SSH Login and Deploy Symphony

on:
  workflow_dispatch:
  push:
    branches:
      - TestAutomation

env:
  VM_HOST: "10.139.9.151"
  VM_USER: "root"
  VM_PASS: "abc123"

jobs:
  deploy:
    runs-on: ubuntu-latest
    #runs-on: self-hosted

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      #- name: Install sshpass
        #run: sudo apt-get update && sudo apt-get install -y sshpass

      #- name: Login to private VM
        #run: |
         # sshpass -p "$VM_PASS" ssh -o StrictHostKeyChecking=no "$VM_USER@$VM_HOST" "echo Hello from Azure VM"
          #set e  
          
      - name: Install Rust
        run: |
            echo "Installing Rust..."
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            source $HOME/.cargo/env

      - name: Clone Symphoy repo
        run: |
            echo "Cloning Symphony repository..."
            rm -rf "$HOME/symphony"
            git clone https://github.com/eclipse-symphony/symphony.git "$HOME/symphony"

      - name: Build rust library
        run: |
            echo "Building Rust library..."
            RUST_DIR="$HOME/symphony/api/pkg/apis/v1alpha1/providers/target/rust"
            if [ -d "$RUST_DIR" ]; then
              cd "$RUST_DIR"
              cargo build --release
            else
              echo "Rust directory not found, skipping Rust build."
            fi
            
      - name: Build Go library
        run: |
            echo "Building Go binary..."
            GO_DIR="$HOME/symphony/api"
            if [ -d "$GO_DIR" ]; then
              export LD_LIBRARY_PATH="$RUST_DIR/target/release"
              cd "$GO_DIR"
              go build -o symphony-api
            else
              echo "Go directory not found, skipping Go build."
            fi

      - name: Run Symphony API
        run: |
          echo "Starting symphony-api in background..."
                API_BIN="$HOME/symphony/api/symphony-api"
                if [ -f "$API_BIN" ]; then
                  nohup env SYMPHONY_API_URL="http://localhost:8082/v1alpha2/" USE_SERVICE_ACCOUNT_TOKENS="false" \
                    "$API_BIN" -c "$HOME/symphony/api/symphony-api-no-k8s.json" -l Debug > "$HOME/symphony-api.log" 2>&1 &
                  echo "symphony-api started in background."
                else
                  echo "symphony-api binary not found, skipping startup."
                fi
           sleep 5
           
            if [ -f "$HOME/symphony-api.log" ]; then
            echo "Log file exists."
            echo "exists=true" >> $GITHUB_OUTPUT
            cp "$HOME/symphony-api.log" ./symphony-api.log
          else
            echo "Log file not found."
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
          
      # - name: Fetch Symphony API log from VM
      #   run: |
      #     sshpass -p "$VM_PASS" scp -o StrictHostKeyChecking=no "$VM_USER@$VM_HOST:~/symphony-api.log" ./symphony-api.log

      # - name: Upload Symphony API log
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: symphony-api-log
      #     path: ./symphony-api.log

  #Harbor Installation
      - name: Harbor installation process begins here. Make the scripts required for installation executable
        run: | 
            set -e
            ls -la ./harbor
            chmod +x ./harbor/install.sh ./harbor/prepare ./harbor/cleanup_harbor.sh

      - name: Ensure correct ownership and apply secure file and folder permissions.directories to 755.files to 644
        run: |
            #sudo chown -R azureuser:azureuser .
            find ./harbor -type d -exec chmod 755 {} \;
            find ./harbor -type f -exec chmod 644 {} \;
            chmod +x ./harbor/install.sh ./harbor/prepare ./harbor/cleanup_harbor.sh
            
      - name: Install harbor
        run: |
            cd ./harbor
            sudo ./install.sh

      #Gogs Installation     
      - name: Install Docker & Docker Compose
        run: |
              sudo apt-get remove -y docker docker-engine docker.io containerd runc || true
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo usermod -aG docker $USER
              sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.6/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose       
              docker version
              docker-compose version          
  
      - name: Start Gogs with Docker Compose
        run: docker-compose up --build -d
  
      - name: Wait for Gogs to be ready
        run: |
          echo "Waiting for Gogs to be ready..."
          for i in {1..30}; do
            if curl -s http://localhost:3000 | grep -q "Gogs"; then
              echo "Gogs is up!"
              break
            fi
            sleep 2
          done
  
      - name: Create admin user inside Gogs container
        run: |
          docker exec -u git custom-gogs /app/gogs/gogs admin create-user \
            --name gogsadmin \
            --password admin123 \
            --email you@example.com \
            --admin || echo "User might already exist, skipping..."
  
      - name: Generate API token
        id: token
        run: |
          TOKEN_RESPONSE=$(curl -s -X POST "http://localhost:3000/api/v1/users/gogsadmin/tokens" \
            -u "gogsadmin:admin123" \
            -H "Content-Type: application/json" \
            -d '{"name": "mytoken"}')
          
          echo "$TOKEN_RESPONSE"
          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.sha1')
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
  
      - name: Create repository using token
        run: |
          curl -X POST -H "Authorization: token ${{ steps.token.outputs.token }}" \
               -H "Content-Type: application/json" \
               -d '{"name":"my-new-repo","private":false}' \
               http://localhost:3000/api/v1/user/repos
